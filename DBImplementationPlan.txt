Database Implementation Plan
============================

Context
-------
We already have a Supabase-hosted PostgreSQL instance with the schema in `DBStructure.txt` deployed and populated with seed data. Front-end (Next.js) is in place; now we need to integrate the backend so the website reads/writes from Supabase securely.

Process Overview
----------------
1. Requirements Validation
   - Reconfirm data flows (menu browsing, cart checkout, order tracking) and map each front-end action to the tables in the schema.
   - Identify missing entities or fields and capture change requests before coding.

2. Supabase Project Setup
   - Ensure we have the Supabase project ID, API keys, and service role key (for server-side mutations) stored in `.env.local`.
   - Enable Row Level Security (RLS) for all tables; create policies for read-only public data (menus) and server-side operations (orders, payments).

3. Backend Folder Structure
   - Create `lib/supabase/server.ts` for admin client (service role key) and `lib/supabase/client.ts` for public client (anon key) to reuse across API routes.
   - Add `lib/db/queries.ts` (or similar) to encapsulate SQL queries/remote procedure calls.

4. Data Fetching Layers
   - Restaurant landing/menu pages (`pages/restaurant/[slug].js`): replace mock fetch with Supabase RPC/queries that load `restaurants`, `menu_categories`, `menu_items`, and modifiers in one batched request (or via Supabase Edge Function if aggregation required).
   - Checkout flow: read restaurant settings (delivery zones, payment options) and persist orders via a Next.js API route that writes to `orders`, `order_items`, and `order_item_modifiers` using the server-side Supabase client.

5. Authentication & Security
   - Since end-users are anonymous, rely on client-side Supabase anon key only for read operations with RLS policy `true` on select. Mutations happen through Next.js API routes using service key so secrets stay server-side.

6. Seed & Migration Management
   - Track schema via SQL migrations stored in `/supabase/migrations` or `db/migrations`. Utilize Supabase CLI to push/pull schema changes.
   - Maintain seed data script (SQL or TS) for local development; load fixtures for restaurants/items to mirror production structure.

7. API Endpoints
   - `/api/restaurants/[slug]/menu`: fetch categories/items/modifiers in response JSON matching current front-end shape.
   - `/api/restaurants/[slug]/orders`: POST endpoint validating payload, calculating totals on server, inserting into orders tables, and returning order ID + status.
   - `/api/orders/[id]`: GET for tracking page (status timeline). Optionally use Supabase realtime to push updates.

8. Client Integration
   - Update `pages/restaurant/[slug].js` and `pages/checkout.js` to call the new API endpoints (rather than local JSON). Ensure caching/ISR if needed.
   - Replace localStorage order persistence with real DB writes; still keep optimistic UI fallback if network fails.

9. Observability
   - Setup Supabase logs + row-level triggers (or `order_events`) for analytics.
   - Monitoring/reporting can remain owner-only for now (no admin simulation), using Supabase dashboard queries or read-only SQL clients.

10. Testing & Verification
   - Write unit tests for data access layer (mock Supabase) and integration tests for Next.js API routes.
   - Verify RLS policies via Supabase CLI tests to ensure unauthorized writes are blocked.

Next Steps
----------
Await your go-ahead. Once approved, we will:
1. Scaffold Supabase clients/env setup.
2. Implement read endpoints (menu data).
3. Implement order submission endpoint and wire checkout.
4. Hook order tracking to DB status.
5. Add tests and deployment instructions.
